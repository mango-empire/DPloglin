% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dapper_sample.R
\name{dapper_sample}
\alias{dapper_sample}
\title{Generate samples from the private posterior.}
\usage{
dapper_sample(
  data_model,
  sdp,
  init_par,
  niter = 2000,
  warmup = floor(niter/2),
  chains = 1
)
}
\arguments{
\item{data_model}{A data model represented by a privacy class object.}

\item{sdp}{The observed privatized data.}

\item{init_par}{Initial starting point of the chain.}

\item{niter}{Number of draws.}

\item{warmup}{Number of iterations to discard as warmup. Default is half of niter.}
}
\value{
A dpout object which contains:
\item{accept_prob}{Acceptance probabilities}
\item{chain}{Samples from the private posterior}
}
\description{
Generate samples from the private posterior.
}
\examples{
#simulate confidential data
#Privacy mechanism adds gaussian noise to each observation.
set.seed(1)
n <- 100
eps <- 3
y <- rnorm(n, mean = -2, sd = 1)
sdp <- mean(y) + rnorm(1, 0, 1/eps)

post_smpl <- function(dmat, theta) {
    x <- c(dmat)
    xbar <- mean(x)
    n <- length(x)
    pr_m <- 0
    pr_s2 <- 4
    ps_s2 <- 1/(1/pr_s2 + n)
    ps_m <- ps_s2 * ((1/pr_s2)*pr_m + n * xbar)
    rnorm(1, mean = ps_m, sd = sqrt(ps_s2))
}
lik_smpl <- function(theta) {
    matrix(rnorm(100, mean = theta, sd = 1), ncol = 1)
}
st_calc <- function(dmat) {
    mean(dmat)
}
priv_mech <- function(sdp, zt) {
  sum(dnorm(sdp - zt, 0, 1/eps, TRUE))
}
dmod <- new_privacy(post_f = post_smpl,
  latent_f = lik_smpl,
  priv_f = priv_mech,
  st_f = st_calc,
  add = FALSE,
  npar = 1)

out <- dapper_sample(dmod,
                    sdp = sdp,
                    init_par = -2,
                    niter = 500)
summary(out)
}
