% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dapper_sample.R
\name{dapper_sample}
\alias{dapper_sample}
\title{Generate samples from the private posterior.}
\usage{
dapper_sample(
  data_model,
  sdp,
  init_par,
  niter = 2000,
  warmup = floor(niter/2),
  chains = 1
)
}
\arguments{
\item{data_model}{a data model represented by a privacy class object.}

\item{sdp}{the observed privatized data. Must be a vector or matrix.}

\item{init_par}{initial starting point of the chain.}

\item{niter}{number of draws.}

\item{warmup}{number of iterations to discard as warmup. Default is half of niter.}

\item{chains}{number of MCMC chains to run. Can be done in parallel or sequentially.}
}
\value{
A dpout object which contains:
\item{accept_prob}{acceptance probabilities.}
\item{chain}{samples from the private posterior.}
}
\description{
Generate samples from the private posterior.
}
\examples{
#simulate confidential data
#Privacy mechanism adds gaussian noise to each observation.
set.seed(1)
n <- 100
eps <- 3
y <- rnorm(n, mean = -2, sd = 1)
sdp <- mean(y) + rnorm(1, 0, 1/eps)

post_f <- function(dmat, theta) {
    x <- c(dmat)
    xbar <- mean(x)
    n <- length(x)
    pr_m <- 0
    pr_s2 <- 4
    ps_s2 <- 1/(1/pr_s2 + n)
    ps_m <- ps_s2 * ((1/pr_s2)*pr_m + n * xbar)
    rnorm(1, mean = ps_m, sd = sqrt(ps_s2))
}
latent_f <- function(theta) {
    matrix(rnorm(100, mean = theta, sd = 1), ncol = 1)
}
st_f <- function(xi, sdp, i) {
    mean(xi)
}
priv_f <- function(sdp, tx) {
  sum(dnorm(sdp - tx, 0, 1/eps, TRUE))
}
dmod <- new_privacy(post_f = post_f,
  latent_f = latent_f,
  priv_f = priv_f,
  st_f = st_f,
  npar = 1)

out <- dapper_sample(dmod,
                    sdp = sdp,
                    init_par = -2,
                    niter = 500)
summary(out)
}
